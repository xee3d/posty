import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  ScrollView,
  TouchableOpacity,
  StyleSheet,
  SafeAreaView,
  TextInput,
  KeyboardAvoidingView,
  Platform,
  Alert,
  Image,
  ActivityIndicator,
} from 'react-native';
import { COLORS, FONTS, SPACING, BORDER_RADIUS, MOLLY_MESSAGES, BRAND, CARD_THEME } from '../utils/constants';
import { useAppTheme } from '../hooks/useAppTheme';
import Icon from 'react-native-vector-icons/Ionicons';
import MaterialIcon from 'react-native-vector-icons/MaterialIcons';
import { useAppSelector } from '../hooks/redux';
import { selectCurrentTokens, selectSubscriptionPlan } from '../store/slices/userSlice';
import EarnTokenModal from '../components/EarnTokenModal';
import { LowTokenPrompt } from '../components/LowTokenPrompt';
import tokenService from '../services/subscription/tokenService';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { AnimatedCard, SlideInView, FadeInView, ScaleButton } from '../components/AnimationComponents';
import GeneratedContentDisplay from '../components/GeneratedContentDisplay';
import aiService from '../services/aiService';
import Clipboard from '@react-native-clipboard/clipboard';
import { saveContent } from '../utils/storage';
import { APP_TEXT, getText } from '../utils/textConstants';
import { soundManager } from '../utils/soundManager';
import { getPlaceholderText, getTimeBasedPrompts, getCategoryFromTone, extractHashtags } from '../utils/promptUtils';
import {
  launchImageLibrary,
  launchCamera,
  ImagePickerResponse,
  ImageLibraryOptions,
  CameraOptions,
} from 'react-native-image-picker';
import localAnalyticsService from '../services/analytics/localAnalyticsService';
import simplePostService from '../services/simplePostService';
import { PLATFORM_STYLES, getRandomEndingStyle, transformContentForPlatform, generateHashtags } from '../utils/platformStyles';
import { useAppDispatch } from '../hooks/redux';
import { useTokens } from '../store/slices/userSlice';

type WriteMode = 'text' | 'photo' | 'polish';

interface AIWriteScreenProps {
  onNavigate?: (tab: string) => void;
  initialMode?: WriteMode;
  initialText?: string;
  initialHashtags?: string[];
  initialTitle?: string;
}

const AIWriteScreen: React.FC<AIWriteScreenProps> = ({ onNavigate, initialMode = 'text', initialText, initialHashtags, initialTitle }) => {
  // console.log('AIWriteScreen mounted with:', { initialText, initialHashtags, initialTitle });
  const { colors, cardTheme, isDark } = useAppTheme();
  const dispatch = useAppDispatch();
  const currentTokens = useAppSelector(selectCurrentTokens);
  const [writeMode, setWriteMode] = useState<WriteMode>(initialMode);
  const [prompt, setPrompt] = useState(initialText || '');
  
  // initialText 변경 시 prompt 업데이트
  useEffect(() => {
    if (initialText) {
      console.log('Setting prompt from initialText:', initialText);
      setPrompt(initialText);
    }
  }, [initialText]);
  const [selectedTone, setSelectedTone] = useState('casual');
  const [selectedLength, setSelectedLength] = useState('medium');
  const [generatedContent, setGeneratedContent] = useState('');
  const [isGenerating, setIsGenerating] = useState(false);
  const [selectedImage, setSelectedImage] = useState<string | null>(null);
  const [selectedPolishOption, setSelectedPolishOption] = useState<'spelling' | 'refine' | 'improve' | 'formal' | 'simple' | 'engaging'>('refine');
  const [selectedImageUri, setSelectedImageUri] = useState<string | null>(null);
  const [initialHashtagsList, setInitialHashtagsList] = useState<string[]>(initialHashtags || []);
  const [imageAnalysis, setImageAnalysis] = useState<string>('');
  const [imageAnalysisResult, setImageAnalysisResult] = useState<any>(null);
  const [showEarnTokenModal, setShowEarnTokenModal] = useState(false);
  const [showLowTokenPrompt, setShowLowTokenPrompt] = useState(false);
  const subscriptionPlan = useAppSelector(selectSubscriptionPlan);

  // initialText가 있을 때 자동으로 콘텐츠 생성
  useEffect(() => {
    if (initialText && currentTokens > 0) {
      // 약간의 딜레이 후 자동 생성
      const timer = setTimeout(() => {
        handleGenerate();
      }, 500);
      
      return () => clearTimeout(timer);
    }
  }, []); // 컴포넌트 마운트 시 한 번만 실행

  const tones = [
    { id: 'casual', label: '캐주얼', icon: '😊' },
    { id: 'professional', label: '전문적', icon: '💼' },
    { id: 'humorous', label: '유머러스', icon: '😄' },
    { id: 'emotional', label: '감성적', icon: '💕' },
    { id: 'genz', label: 'GenZ', icon: '🔥' },
    { id: 'millennial', label: '밀레니얼', icon: '☕' },
    { id: 'minimalist', label: '미니멀', icon: '⚪' },
    { id: 'storytelling', label: '스토리텔링', icon: '📖' },
    { id: 'motivational', label: '동기부여', icon: '💪' },
  ];

  const lengths = [
    { id: 'short', label: '🩳', count: '짧게', desc: '~50자' },
    { id: 'medium', label: '👕', count: '보통', desc: '~150자' },
    { id: 'long', label: '🥼', count: '길게', desc: '~300자' },
  ];

  // promptUtils로 이동됨

  const quickPrompts = getTimeBasedPrompts();

  const handleSelectImage = () => {
    Alert.alert(
      '사진 선택',
      '어떤 방법으로 사진을 선택하시겠어요?',
      [
        { text: '취소', style: 'cancel' },
        { 
          text: '카메라로 촬영', 
          onPress: () => openCamera() 
        },
        { 
          text: '갤러리에서 선택', 
          onPress: () => openImageLibrary() 
        },
      ],
      { cancelable: true }
    );
  };

  const analyzeImageImmediately = async (imageUrl: string) => {
    try {
      setImageAnalysis('이미지를 분석하는 중...');
      
      const analysis = await aiService.analyzeImage({
        imageUri: imageUrl,
      });
      
      console.log('Image analysis completed:', analysis);
      setImageAnalysis(analysis.description);
      setImageAnalysisResult(analysis);
      
      return analysis;
    } catch (error) {
      console.error('Image analysis failed:', error);
      setImageAnalysis('이미지 분석에 실패했습니다.');
      return null;
    }
  };

  const openImageLibrary = () => {
    const options: ImageLibraryOptions = {
      mediaType: 'photo',
      includeBase64: true,
      maxHeight: 2000,
      maxWidth: 2000,
      quality: 0.8,
    };

    launchImageLibrary(options, (response: ImagePickerResponse) => {
      if (response.didCancel) {
        console.log('사용자가 이미지 선택을 취소했습니다');
      } else if (response.errorMessage) {
        console.error('ImagePicker Error: ', response.errorMessage);
        Alert.alert('오류', '이미지를 선택하는 중 문제가 발생했습니다.');
      } else if (response.assets && response.assets[0]) {
        const asset = response.assets[0];
        if (asset.uri) {
          setSelectedImageUri(asset.uri);
          
          if (asset.base64) {
            const base64Url = `data:image/jpeg;base64,${asset.base64}`;
            setSelectedImage(base64Url);
            analyzeImageImmediately(base64Url);
          } else {
            setSelectedImage(asset.uri);
            analyzeImageImmediately(asset.uri);
          }
        }
      }
    });
  };

  const openCamera = () => {
    const options: CameraOptions = {
      mediaType: 'photo',
      includeBase64: true,
      maxHeight: 2000,
      maxWidth: 2000,
      quality: 0.8,
      saveToPhotos: true,
    };

    launchCamera(options, (response: ImagePickerResponse) => {
      if (response.didCancel) {
        console.log('사용자가 카메라 촬영을 취소했습니다');
      } else if (response.errorMessage) {
        console.error('Camera Error: ', response.errorMessage);
        Alert.alert('오류', '카메라를 사용하는 중 문제가 발생했습니다.');
      } else if (response.assets && response.assets[0]) {
        const asset = response.assets[0];
        if (asset.uri) {
          setSelectedImageUri(asset.uri);
          
          if (asset.base64) {
            const base64Url = `data:image/jpeg;base64,${asset.base64}`;
            setSelectedImage(base64Url);
            analyzeImageImmediately(base64Url);
          } else {
            setSelectedImage(asset.uri);
            analyzeImageImmediately(asset.uri);
          }
        }
      }
    });
  };

  const handleGenerate = async () => {
    if (!prompt.trim() && writeMode !== 'photo') {
      Alert.alert('포스티 알림', '무엇에 대해 쓸지 알려주세요! 🤔');
      return;
    }

    if (writeMode === 'photo' && !selectedImage) {
      Alert.alert('포스티 알림', '사진을 먼저 선택해주세요! 📸');
      return;
    }

    // 토큰 체크
    const requiredTokens = writeMode === 'photo' ? 2 : 1;
    if (currentTokens < requiredTokens && currentTokens !== 9999) { // 9999는 무제한
      // 무료 사용자는 자동 프롬프트 표시
      if (subscriptionPlan === 'free') {
        setShowLowTokenPrompt(true);
      } else {
        Alert.alert(
          '토큰 부족',
          `이 기능은 ${requiredTokens}개의 토큰이 필요해요. 현재 ${currentTokens}개의 토큰이 남아있어요.`,
          [
            { text: '확인', style: 'cancel' },
            { 
              text: '구독하기', 
              onPress: () => onNavigate?.('subscription')
            },
          ]
        );
      }
      return;
    }

    setIsGenerating(true);
    try {
      // 토큰 사용
      const tokenDescription = writeMode === 'photo' ? '사진 글쓰기' : 
                             writeMode === 'polish' ? '문장 정리' : 
                             prompt || '새글 생성';
      
      dispatch(useTokens({ 
        amount: requiredTokens, 
        description: tokenDescription 
      }));

      let result = '';
      
      if (writeMode === 'text') {
        console.log('Generating text content with prompt:', prompt);
        const response = await aiService.generateContent({
          prompt: prompt.trim(),
          tone: selectedTone as any,
          length: selectedLength,
          hashtags: initialHashtagsList.length > 0 ? initialHashtagsList : undefined,
        });
        // 객체에서 content 문자열만 추출
        result = response.content;
      } else if (writeMode === 'polish') {
        console.log('Polishing content with text:', prompt);
        const response = await aiService.polishContent({
          text: prompt.trim(),
          polishType: selectedPolishOption,
          tone: selectedTone as any,
          length: selectedLength,
        });
        // 객체에서 content 문자열만 추출
        result = response.content;
      } else if (writeMode === 'photo') {
        // generateFromImage 메서드가 없으므로 generateContent 사용
        const photoPrompt = imageAnalysis || '사진을 보고 작성하는 글';
        console.log('Generating photo content with analysis:', photoPrompt);
        const response = await aiService.generateContent({
          prompt: photoPrompt.trim(),
          tone: selectedTone as any,
          length: selectedLength,
          hashtags: initialHashtagsList.length > 0 ? initialHashtagsList : undefined,
        });
        result = response.content;
      }
      
      setGeneratedContent(result);
      
      // 데이터 자동 저장
      if (result) {
        const hashtags = extractHashtags(result);
        
        // storage.ts의 saveContent 호출
        await saveContent({
          content: result,
          hashtags: hashtags,
          tone: selectedTone,
          length: selectedLength,
          platform: 'general',
          prompt: writeMode === 'photo' ? '사진 글쓰기' : prompt,
        });
        
        // simplePostService에도 저장 (MyStyleScreen 분석용)
        await simplePostService.savePost({
          content: result,
          hashtags: hashtags,
          platform: 'general',
          category: getCategoryFromTone(selectedTone),
          tone: selectedTone,
        });
        
        console.log('Content saved successfully');
      }
    } catch (error) {
      console.error('Generation error:', error);
      Alert.alert('포스티 알림', '앗! 뭔가 문제가 생겼어요. 다시 시도해주세요 🥺');
    } finally {
      setIsGenerating(false);
    }
  };


  const handleQuickPrompt = (quickPrompt: string) => {
    setPrompt(quickPrompt);
  };

  const getRandomEncouragement = () => {
    const encouragements = MOLLY_MESSAGES.encouragements;
    return encouragements[Math.floor(Math.random() * encouragements.length)];
  };

  const handleSaveContent = async (platform: string = 'instagram', editedContent?: string) => {
    try {
      const contentToSave = editedContent || generatedContent;
      // 플랫폼별 해시태그 조정
      const adjustedHashtags = generateHashtags(extractHashtags(contentToSave), platform);
      
      // 기존 저장 로직
      await saveContent({
        content: contentToSave,
        hashtags: adjustedHashtags,
        tone: selectedTone,
        length: selectedLength,
        platform: platform,
        prompt: writeMode === 'photo' ? '사진 글쓰기' : prompt,
      });
      
      // 단순화된 서비스에 저장 (성과 지표 없이)
      await simplePostService.savePost({
        content: contentToSave,
        hashtags: adjustedHashtags,
        platform: platform as 'instagram' | 'facebook' | 'twitter' | 'general',
        category: getCategoryFromTone(selectedTone),
        tone: selectedTone,
      });
      
      Alert.alert(
        '저장 완료! 💾', 
        '콘텐츠가 저장되었어요.\n\n성과는 각 SNS 플랫폼에서 확인하세요!',
        [{ text: '확인', style: 'default' }]
      );
    } catch (error) {
      console.error('Save error:', error);
      Alert.alert('오류', '저장 중 문제가 발생했어요.');
    }
  };
  
  // promptUtils로 이동됨

  const handleEarnTokens = async (tokens: number) => {
    try {
      const subscription = await tokenService.getSubscription();
      subscription.dailyTokens = Math.min(subscription.dailyTokens + tokens, 30);
      await AsyncStorage.setItem('USER_SUBSCRIPTION', JSON.stringify(subscription));
      
      Alert.alert(
        '토큰 획듍! 🎉',
        `${tokens}개의 토큰을 받았어요!`,
        [{ text: '확인' }]
      );
    } catch (error) {
      console.error('Failed to add tokens:', error);
    }
  };

  const styles = createStyles(colors, cardTheme);

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView 
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <ScrollView 
          style={styles.content}
          showsVerticalScrollIndicator={false}
          contentContainerStyle={styles.scrollContent}
        >
          {/* 헤더 */}
          <FadeInView delay={0}>
            <View style={styles.header}>
              <View style={styles.headerTop}>
                <View style={styles.mollyBadge}>
                  <Text style={styles.mollyBadgeText}>P</Text>
                </View>
                <Text style={styles.headerTitle}>포스티와 글쓰기</Text>
                {/* 토큰 표시 */}
                <View style={styles.tokenBadge}>
                  <Icon name="flash" size={16} color={currentTokens === 0 ? colors.error : colors.primary} />
                  <Text style={[styles.tokenText, currentTokens === 0 && styles.tokenTextEmpty]}>
                    {currentTokens === 9999 ? '무제한' : currentTokens}
                  </Text>
                </View>
              </View>
              <Text style={styles.headerSubtitle}>
                {writeMode === 'text' 
                  ? '어떤 이야기를 써볼까요? 제가 도와드릴게요!'
                  : writeMode === 'polish'
                  ? '작성하신 글을 더 멋지게 다듬어드릴게요!'
                  : '사진을 보여주시면 어울리는 글을 만들어드려요!'}
              </Text>
            </View>
          </FadeInView>

          {/* 모드 선택 */}
          <SlideInView direction="up" delay={100}>
            <ScrollView 
              horizontal 
              showsHorizontalScrollIndicator={false}
              style={styles.modeSelectorScroll}
            >
              <View style={styles.modeSelector}>
                <ScaleButton
                  style={[styles.modeButton, writeMode === 'text' && styles.modeButtonActive]}
                  onPress={() => setWriteMode('text')}
                >
                  <MaterialIcon 
                    name="edit" 
                    size={18} 
                    color={writeMode === 'text' ? colors.white : colors.text.secondary} 
                  />
                  <Text style={[
                    styles.modeButtonText,
                    writeMode === 'text' && styles.modeButtonTextActive
                  ]}>
                    새글 쓰기
                  </Text>
                </ScaleButton>
                <ScaleButton
                  style={[styles.modeButton, writeMode === 'polish' && styles.modeButtonActive]}
                  onPress={() => setWriteMode('polish')}
                >
                  <MaterialIcon 
                    name="auto-fix-high" 
                    size={18} 
                    color={writeMode === 'polish' ? colors.white : colors.text.secondary} 
                  />
                  <Text style={[
                    styles.modeButtonText,
                    writeMode === 'polish' && styles.modeButtonTextActive
                  ]}>
                    문장 정리
                  </Text>
                </ScaleButton>
                <ScaleButton
                  style={[styles.modeButton, writeMode === 'photo' && styles.modeButtonActive]}
                  onPress={() => setWriteMode('photo')}
                >
                  <MaterialIcon 
                    name="image" 
                    size={18} 
                    color={writeMode === 'photo' ? colors.white : colors.text.secondary} 
                  />
                  <Text style={[
                    styles.modeButtonText,
                    writeMode === 'photo' && styles.modeButtonTextActive
                  ]}>
                    사진 글쓰기
                  </Text>
                </ScaleButton>
              </View>
            </ScrollView>
          </SlideInView>

          {writeMode === 'text' ? (
            <>
              {/* 텍스트 모드 */}
              <SlideInView direction="left" delay={200}>
                <View style={styles.inputSection}>
                  <Text style={styles.sectionTitle}>무엇에 대해 쓸까요?</Text>
                  <View style={styles.inputContainer}>
                    <TextInput
                      style={styles.input}
                      placeholder={getPlaceholderText()}
                      placeholderTextColor={colors.text.tertiary}
                      value={prompt}
                      onChangeText={setPrompt}
                      multiline
                      maxLength={100}
                    />
                    <Text style={styles.charCount}>{prompt.length}/100</Text>
                  </View>
                  
                  {/* 빠른 주제 선택 */}
                  <ScrollView 
                    horizontal 
                    showsHorizontalScrollIndicator={false}
                    style={styles.quickPromptsScroll}
                  >
                    {quickPrompts.map((quickPrompt, index) => (
                      <AnimatedCard
                        key={index}
                        delay={300 + index * 50}
                        style={styles.quickPromptChip}
                        onPress={() => handleQuickPrompt(quickPrompt)}
                      >
                        <Text style={styles.quickPromptText}>{quickPrompt}</Text>
                      </AnimatedCard>
                    ))}
                  </ScrollView>
                </View>
              </SlideInView>
            </>
          ) : writeMode === 'polish' ? (
            <>
              {/* 문장 정리 모드 */}
              <SlideInView direction="right" delay={200}>
                <View style={styles.inputSection}>
                  <Text style={styles.sectionTitle}>정리하고 싶은 글을 입력해주세요</Text>
                  <View style={styles.inputContainer}>
                    <TextInput
                      style={[styles.input, styles.polishInput]}
                      placeholder="예: 오늘 카페에서 친구랑 커피마시면서 오럫동안 이야기했더니 너무 좋았다..."
                      placeholderTextColor={colors.text.tertiary}
                      value={prompt}
                      onChangeText={setPrompt}
                      multiline
                      maxLength={500}
                    />
                    <Text style={styles.charCount}>{prompt.length}/500</Text>
                  </View>
                  
                  {/* 정리 옵션 */}
                  <View style={styles.polishOptions}>
                    <Text style={styles.polishOptionTitle}>원하는 변환 방향</Text>
                    <View style={styles.polishOptionButtons}>
                      <TouchableOpacity 
                        style={[
                          styles.polishOptionButton,
                          selectedPolishOption === 'spelling' && styles.polishOptionButtonActive
                        ]}
                        onPress={() => setSelectedPolishOption('spelling')}
                      >
                        <Icon 
                          name="checkmark-circle" 
                          size={16} 
                          color={selectedPolishOption === 'spelling' ? colors.white : colors.primary} 
                        />
                        <Text style={[
                          styles.polishOptionText,
                          selectedPolishOption === 'spelling' && styles.polishOptionTextActive
                        ]}>맞춤법 교정</Text>
                      </TouchableOpacity>
                      <TouchableOpacity 
                        style={[
                          styles.polishOptionButton,
                          selectedPolishOption === 'refine' && styles.polishOptionButtonActive
                        ]}
                        onPress={() => setSelectedPolishOption('refine')}
                      >
                        <Icon 
                          name="color-wand" 
                          size={16} 
                          color={selectedPolishOption === 'refine' ? colors.white : colors.primary} 
                        />
                        <Text style={[
                          styles.polishOptionText,
                          selectedPolishOption === 'refine' && styles.polishOptionTextActive
                        ]}>문장 다듬기</Text>
                      </TouchableOpacity>
                      <TouchableOpacity 
                        style={[
                          styles.polishOptionButton,
                          selectedPolishOption === 'improve' && styles.polishOptionButtonActive
                        ]}
                        onPress={() => setSelectedPolishOption('improve')}
                      >
                        <Icon 
                          name="sparkles" 
                          size={16} 
                          color={selectedPolishOption === 'improve' ? colors.white : colors.primary} 
                        />
                        <Text style={[
                          styles.polishOptionText,
                          selectedPolishOption === 'improve' && styles.polishOptionTextActive
                        ]}>표현 개선</Text>
                      </TouchableOpacity>
                    </View>
                    
                    {/* 두 번째 줄: 새로운 3개 */}
                    <View style={[styles.polishOptionButtons, { marginTop: SPACING.sm }]}>
                      <TouchableOpacity 
                        style={[
                          styles.polishOptionButton,
                          selectedPolishOption === 'formal' && styles.polishOptionButtonActive
                        ]}
                        onPress={() => setSelectedPolishOption('formal')}
                      >
                        <MaterialIcon 
                          name="business" 
                          size={16} 
                          color={selectedPolishOption === 'formal' ? colors.white : colors.primary} 
                        />
                        <Text style={[
                          styles.polishOptionText,
                          selectedPolishOption === 'formal' && styles.polishOptionTextActive
                        ]}>격식체 변환</Text>
                      </TouchableOpacity>
                      
                      <TouchableOpacity 
                        style={[
                          styles.polishOptionButton,
                          selectedPolishOption === 'simple' && styles.polishOptionButtonActive
                        ]}
                        onPress={() => setSelectedPolishOption('simple')}
                      >
                        <MaterialIcon 
                          name="child-care" 
                          size={16} 
                          color={selectedPolishOption === 'simple' ? colors.white : colors.primary} 
                        />
                        <Text style={[
                          styles.polishOptionText,
                          selectedPolishOption === 'simple' && styles.polishOptionTextActive
                        ]}>쉽게 풀어쓰기</Text>
                      </TouchableOpacity>
                      
                      <TouchableOpacity 
                        style={[
                          styles.polishOptionButton,
                          selectedPolishOption === 'engaging' && styles.polishOptionButtonActive
                        ]}
                        onPress={() => setSelectedPolishOption('engaging')}
                      >
                        <MaterialIcon 
                          name="favorite" 
                          size={16} 
                          color={selectedPolishOption === 'engaging' ? colors.white : colors.primary} 
                        />
                        <Text style={[
                          styles.polishOptionText,
                          selectedPolishOption === 'engaging' && styles.polishOptionTextActive
                        ]}>매력적으로</Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                </View>
              </SlideInView>
            </>
          ) : (
            <>
              {/* 사진 모드 */}
              <SlideInView direction="right" delay={200}>
                <View style={styles.photoSection}>
                  <Text style={styles.sectionTitle}>사진을 보여주세요!</Text>
                  <ScaleButton 
                    style={styles.photoUploadArea}
                    onPress={handleSelectImage}
                  >
                    {selectedImageUri ? (
                      <View style={styles.selectedImageContainer}>
                        <Image source={{ uri: selectedImageUri }} style={styles.selectedImage} />
                        <TouchableOpacity 
                        style={styles.changePhotoButton}
                        onPress={() => {
                          setImageAnalysisResult(null);
                          handleSelectImage();
                        }}
                      >
                          <Icon name="camera" size={16} color="#FFFFFF" />
                          <Text style={styles.changePhotoText}>변경</Text>
                        </TouchableOpacity>
                      </View>
                    ) : (
                      <View style={styles.uploadPlaceholder}>
                        <View style={styles.uploadIconContainer}>
                          <Icon name="image-outline" size={48} color="#8E8E93" />
                        </View>
                        <Text style={styles.uploadTitle}>사진을 선택해주세요</Text>
                        <Text style={styles.uploadSubtitle}>갤러리에서 선택하거나 직접 촬영하세요</Text>
                        <View style={styles.uploadButton}>
                          <Icon name="add" size={20} color={COLORS.primary} />
                          <Text style={styles.uploadButtonText}>사진 선택</Text>
                        </View>
                      </View>
                    )}
                  </ScaleButton>

                  {/* 몰리의 분석 */}
                  {imageAnalysis && (
                    <FadeInView delay={300}>
                      <View style={styles.analysisCard}>
                        <View style={styles.analysisHeader}>
                          <MaterialIcon name="auto-awesome" size={20} color="#7C3AED" />
                          <Text style={styles.analysisTitle}>포스티가 본 사진</Text>
                        </View>
                        <Text style={styles.analysisText}>{imageAnalysis}</Text>
                      </View>
                    </FadeInView>
                  )}
                </View>
              </SlideInView>
            </>
          )}

          {/* 톤 선택 - 문장 정리 모드에서는 숨김 */}
          {writeMode !== 'polish' && (
            <SlideInView direction="up" delay={600}>
              <View style={styles.optionSection}>
                <Text style={styles.sectionTitle}>어떤 느낌으로 쓸까요?</Text>
                <View style={styles.toneGrid}>
                  {tones.map((tone, index) => (
                    <AnimatedCard
                      key={tone.id}
                      delay={700 + index * 50}
                      style={[
                        styles.toneCard,
                        selectedTone === tone.id && styles.toneCardActive
                      ]}
                      onPress={() => setSelectedTone(tone.id)}
                    >
                      <Text style={styles.toneIcon}>{tone.icon}</Text>
                      <Text style={[
                        styles.toneLabel,
                        selectedTone === tone.id && styles.toneLabelActive
                      ]}>
                        {tone.label}
                      </Text>
                    </AnimatedCard>
                  ))}
                </View>
              </View>
            </SlideInView>
          )}

          {/* 길이 선택 */}
          <SlideInView direction="up" delay={900}>
            <View style={styles.optionSection}>
              <Text style={styles.sectionTitle}>얼마나 길게 쓸까요?</Text>
              <View style={styles.lengthOptions}>
                {lengths.map((length, index) => (
                  <AnimatedCard
                    key={length.id}
                    delay={1000 + index * 50}
                    style={[
                      styles.lengthCard,
                      selectedLength === length.id && styles.lengthCardActive
                    ]}
                    onPress={() => setSelectedLength(length.id)}
                  >
                    <Text style={[
                      styles.lengthEmoji,
                      selectedLength === length.id && styles.lengthEmojiActive
                    ]}>
                      {length.label}
                    </Text>
                    <Text style={[
                      styles.lengthCount,
                      selectedLength === length.id && styles.lengthCountActive
                    ]}>
                      {length.count}
                    </Text>
                    <Text style={[
                      styles.lengthDesc,
                      selectedLength === length.id && styles.lengthDescActive
                    ]}>
                      {length.desc}
                    </Text>
                  </AnimatedCard>
                ))}
              </View>
            </View>
          </SlideInView>

          {/* 생성 버튼 */}
          <FadeInView delay={1200}>
            <View style={styles.generateButtonContainer}>
              <ScaleButton 
                style={[
                  styles.generateButton, 
                  isGenerating && styles.generateButtonDisabled,
                  (currentTokens === 0 || (writeMode === 'photo' && currentTokens === 1)) && styles.generateButtonNoToken
                ]}
                onPress={handleGenerate}
                disabled={currentTokens === 0 || (writeMode === 'photo' && currentTokens === 1)}
              >
                <View style={styles.generateButtonContent}>
                  <View style={styles.generateButtonMain}>
                    {isGenerating ? (
                      <ActivityIndicator size="small" color={colors.white} />
                    ) : (
                      <MaterialIcon 
                        name="auto-awesome" 
                        size={20} 
                        color={(currentTokens === 0 || (writeMode === 'photo' && currentTokens === 1)) ? colors.text.tertiary : "#FFFFFF"} 
                      />
                    )}
                    <Text style={[
                      styles.generateButtonText,
                      (currentTokens === 0 || (writeMode === 'photo' && currentTokens === 1)) && styles.generateButtonTextDisabled
                    ]}>
                      {isGenerating ? '포스티가 쓰는 중...' : '포스티에게 부탁하기'}
                    </Text>
                  </View>
                  {!isGenerating && currentTokens > 0 && !(writeMode === 'photo' && currentTokens === 1) && (
                    <View style={styles.tokenCostBadge}>
                      <Icon name="flash" size={14} color="#FFFFFF" />
                      <Text style={styles.tokenCostText}>
                        {writeMode === 'photo' ? '2' : '1'}
                      </Text>
                    </View>
                  )}
                  {!isGenerating && (currentTokens === 0 || (writeMode === 'photo' && currentTokens === 1)) && (
                    <View style={[styles.tokenCostBadge, styles.tokenCostBadgeEmpty]}>
                      <Icon name="flash-off" size={14} color={colors.text.tertiary} />
                      <Text style={[styles.tokenCostText, styles.tokenCostTextEmpty]}>0</Text>
                    </View>
                  )}
                </View>
              </ScaleButton>
              {currentTokens === 0 && (
                <TouchableOpacity 
                  style={styles.subscribeHint}
                  onPress={() => onNavigate?.('subscription')}
                >
                  <Text style={styles.subscribeHintText}>토큰이 부족해요. 구독하시겠어요?</Text>
                </TouchableOpacity>
              )}
            </View>
          </FadeInView>

          {/* 생성된 콘텐츠 - 개선된 컴포넌트 사용 */}
          {generatedContent && (
            <SlideInView direction="up" delay={0}>
              <View style={styles.resultSection}>
                <View style={styles.resultHeader}>
                  <Text style={styles.resultTitle}>짠! 완성됐어요 🎉</Text>
                  <ScaleButton onPress={handleGenerate}>
                    <Icon name="refresh" size={20} color={COLORS.primary} />
                  </ScaleButton>
                </View>
                
                <FadeInView delay={100}>
                  <View style={styles.mollyComment}>
                    <Text style={styles.mollyCommentText}>{getRandomEncouragement()}</Text>
                  </View>
                </FadeInView>
                
                {/* 새로운 GeneratedContentDisplay 컴포넌트 사용 */}
                <AnimatedCard delay={200}>
                  <GeneratedContentDisplay
                    originalContent={generatedContent}
                    tone={selectedTone}

                    onEdit={(content) => {
                      setGeneratedContent(content);
                    }}
                    onSave={(platform) => handleSaveContent(platform, generatedContent)}
                  />
                </AnimatedCard>
              </View>
            </SlideInView>
          )}

          <View style={styles.bottomSpace} />
        </ScrollView>
      </KeyboardAvoidingView>
      
      {/* 무료 토큰 받기 모달 */}
      <EarnTokenModal
        visible={showEarnTokenModal}
        onClose={() => setShowEarnTokenModal(false)}
        onTokensEarned={handleEarnTokens}
      />
      
      {/* 토큰 부족 자동 프롬프트 */}
      {showLowTokenPrompt && (
        <LowTokenPrompt
          visible={showLowTokenPrompt}
          currentTokens={currentTokens}
          onClose={() => setShowLowTokenPrompt(false)}
          onEarnTokens={() => {
            setShowLowTokenPrompt(false);
            setShowEarnTokenModal(true);
          }}
          onUpgrade={() => {
            setShowLowTokenPrompt(false);
            onNavigate?.('subscription');
          }}
        />
      )}
    </SafeAreaView>
  );
};

const createStyles = (colors: typeof COLORS, cardTheme: typeof CARD_THEME) => 
  StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.background,
  },
  keyboardView: {
    flex: 1,
  },
  content: {
    flex: 1,
  },
  scrollContent: {
    paddingBottom: 100,
  },
  header: {
    paddingHorizontal: SPACING.lg,
    paddingTop: SPACING.xl,
    paddingBottom: SPACING.lg,
  },
  headerTop: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: SPACING.sm,
  },
  mollyBadge: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: colors.primary,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: SPACING.sm,
  },
  mollyBadgeText: {
    fontSize: 18,
    fontWeight: '700',
    color: colors.white,
  },
  headerTitle: {
    fontSize: 28,
    fontWeight: '700',
    color: colors.text.primary,
    letterSpacing: -0.5,
  },
  headerSubtitle: {
    fontSize: 15,
    color: colors.text.secondary,
    lineHeight: 22,
  },
  modeSelectorScroll: {
    marginHorizontal: SPACING.lg,
    marginBottom: SPACING.xl,
  },
  modeSelector: {
    flexDirection: 'row',
    backgroundColor: colors.lightGray,
    borderRadius: 12,
    padding: 4,
    gap: 4,
  },
  modeButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 6,
    paddingVertical: SPACING.sm,
    paddingHorizontal: SPACING.md,
    borderRadius: 8,
    minWidth: 100,
  },
  modeButtonActive: {
    backgroundColor: colors.primary,
  },
  modeButtonText: {
    fontSize: 13,
    fontWeight: '600',
    color: colors.text.secondary,
  },
  modeButtonTextActive: {
    color: colors.white,
  },
  inputSection: {
    paddingHorizontal: SPACING.lg,
    marginBottom: SPACING.xl,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: colors.text.primary,
    marginBottom: SPACING.md,
  },
  inputContainer: {
    backgroundColor: '#FFFFFF',
    borderRadius: 16,
    padding: SPACING.md,
    borderWidth: 1,
    borderColor: '#F3F4F6',
  },
  input: {
    fontSize: 15,
    color: '#1A1A1A',
    minHeight: 80,
    textAlignVertical: 'top',
  },
  polishInput: {
    minHeight: 120,
  },
  polishOptions: {
    marginTop: SPACING.md,
  },
  polishOptionTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: colors.text.secondary,
    marginBottom: SPACING.sm,
  },
  polishOptionButtons: {
    flexDirection: 'row',
    gap: SPACING.sm,
  },
  polishOptionButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 6,
    paddingVertical: SPACING.sm,
    paddingHorizontal: SPACING.sm,
    backgroundColor: colors.surface,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: colors.border,
  },
  polishOptionButtonActive: {
    backgroundColor: colors.primary,
    borderColor: colors.primary,
  },
  polishOptionText: {
    fontSize: 12,
    color: colors.text.secondary,
    fontWeight: '500',
  },
  polishOptionTextActive: {
    color: colors.white,
  },
  charCount: {
    fontSize: 12,
    color: '#8E8E93',
    textAlign: 'right',
    marginTop: SPACING.xs,
  },
  quickPromptsScroll: {
    marginTop: SPACING.sm,
  },
  quickPromptChip: {
    backgroundColor: '#F3F4F6',
    paddingHorizontal: SPACING.md,
    paddingVertical: SPACING.sm,
    borderRadius: 20,
    marginRight: SPACING.sm,
  },
  quickPromptText: {
    fontSize: 14,
    color: '#6B7280',
  },
  photoSection: {
    paddingHorizontal: SPACING.lg,
    marginBottom: SPACING.xl,
  },
  photoUploadArea: {
    backgroundColor: '#FFFFFF',
    borderRadius: 16,
    borderWidth: 2,
    borderColor: '#F3F4F6',
    borderStyle: 'dashed',
    overflow: 'hidden',
  },
  uploadPlaceholder: {
    padding: SPACING.xl,
    alignItems: 'center',
  },
  uploadIconContainer: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: '#F8F9FA',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: SPACING.md,
  },
  uploadTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1A1A1A',
    marginBottom: SPACING.xs,
  },
  uploadSubtitle: {
    fontSize: 14,
    color: '#8E8E93',
    marginBottom: SPACING.md,
  },
  uploadButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: SPACING.xs,
    backgroundColor: '#FFF7F5',
    paddingHorizontal: SPACING.lg,
    paddingVertical: SPACING.sm,
    borderRadius: 20,
  },
  uploadButtonText: {
    fontSize: 14,
    fontWeight: '600',
    color: COLORS.primary,
  },
  selectedImageContainer: {
    position: 'relative',
  },
  selectedImage: {
    width: '100%',
    height: 200,
    resizeMode: 'cover',
  },
  changePhotoButton: {
    position: 'absolute',
    bottom: SPACING.md,
    right: SPACING.md,
    flexDirection: 'row',
    alignItems: 'center',
    gap: SPACING.xs,
    backgroundColor: 'rgba(0,0,0,0.7)',
    paddingHorizontal: SPACING.md,
    paddingVertical: SPACING.sm,
    borderRadius: 20,
  },
  changePhotoText: {
    fontSize: 13,
    color: '#FFFFFF',
    fontWeight: '500',
  },
  analysisCard: {
    backgroundColor: cardTheme.molly.background,
    borderRadius: 12,
    padding: SPACING.md,
    marginTop: SPACING.md,
  },
  analysisHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: SPACING.xs,
    marginBottom: SPACING.xs,
  },
  analysisTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: colors.primary,
  },
  analysisText: {
    fontSize: 14,
    color: colors.text.secondary,
    lineHeight: 20,
  },
  optionSection: {
    paddingHorizontal: SPACING.lg,
    marginBottom: SPACING.xl,
  },
  toneGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: SPACING.sm,
  },
  toneCard: {
    minWidth: '30%',
    backgroundColor: colors.surface,
    borderRadius: 12,
    padding: SPACING.md,
    alignItems: 'center',
    borderWidth: 1,
    borderColor: colors.border,
  },
  toneCardActive: {
    borderColor: colors.primary,
    backgroundColor: cardTheme.molly.background,
  },
  toneIcon: {
    fontSize: 24,
    marginBottom: SPACING.xs,
  },
  toneLabel: {
    fontSize: 13,
    color: colors.text.secondary,
    fontWeight: '500',
  },
  toneLabelActive: {
    color: colors.primary,
  },
  lengthOptions: {
    flexDirection: 'row',
    gap: SPACING.sm,
  },
  lengthCard: {
    flex: 1,
    backgroundColor: colors.surface,
    borderRadius: 12,
    padding: SPACING.md,
    alignItems: 'center',
    borderWidth: 1,
    borderColor: colors.border,
  },
  lengthCardActive: {
    borderColor: colors.primary,
    backgroundColor: cardTheme.molly.background,
  },
  lengthLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: colors.text.secondary,
  },
  lengthLabelActive: {
    color: colors.primary,
  },
  lengthCount: {
    fontSize: 12,
    color: colors.text.tertiary,
    marginTop: 4,
  },
  lengthCountActive: {
    color: colors.primary,
  },
  lengthEmoji: {
    fontSize: 28,
    marginBottom: SPACING.xs,
  },
  lengthEmojiActive: {
    transform: [{ scale: 1.1 }],
  },
  lengthDesc: {
    fontSize: 11,
    color: colors.text.tertiary,
    marginTop: 2,
  },
  lengthDescActive: {
    color: colors.primary,
  },
  generateButton: {
    backgroundColor: colors.primary,
    marginHorizontal: SPACING.lg,
    paddingVertical: 14,
    borderRadius: 16,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: colors.black,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 3,
  },
  generateButtonDisabled: {
    opacity: 0.6,
  },
  generateButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: colors.white,
    marginLeft: 8,
  },
  resultSection: {
    marginTop: SPACING.xl,
  },
  resultHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: SPACING.lg,
    marginBottom: SPACING.sm,
  },
  resultTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: colors.text.primary,
  },
  mollyComment: {
    marginHorizontal: SPACING.lg,
    marginBottom: SPACING.md,
    backgroundColor: cardTheme.molly.background,
    borderRadius: 12,
    padding: SPACING.md,
  },
  mollyCommentText: {
    fontSize: 14,
    color: colors.text.primary,
    fontWeight: '500',
  },
  bottomSpace: {
    height: SPACING.xxl,
  },
  tokenBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: colors.surface,
    paddingHorizontal: SPACING.sm,
    paddingVertical: 6,
    borderRadius: 16,
    gap: 4,
    marginLeft: 'auto',
  },
  tokenText: {
    fontSize: 14,
    fontWeight: '600',
    color: colors.primary,
  },
  tokenTextEmpty: {
    color: colors.error,
  },
  generateButtonContainer: {
    marginHorizontal: SPACING.lg,
  },
  subscribeHint: {
    marginTop: SPACING.sm,
    alignItems: 'center',
  },
  subscribeHintText: {
    fontSize: 13,
    color: colors.primary,
    textDecorationLine: 'underline',
  },
  tokenCostBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    marginLeft: 8,
    gap: 2,
  },
  tokenCostText: {
    fontSize: 12,
    fontWeight: '600',
    color: colors.white,
  },
  generateButtonNoToken: {
    backgroundColor: colors.lightGray,
    borderWidth: 1,
    borderColor: colors.border,
  },
  generateButtonTextDisabled: {
    color: colors.text.tertiary,
  },
  tokenCostBadgeEmpty: {
    backgroundColor: 'rgba(0, 0, 0, 0.1)',
  },
  tokenCostTextEmpty: {
    color: colors.text.tertiary,
  },
  generateButtonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    width: '100%',
  },
  generateButtonMain: {
    flexDirection: 'row',
    alignItems: 'center',
  },
});

export default AIWriteScreen;
